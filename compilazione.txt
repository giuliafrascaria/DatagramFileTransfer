---------------------------------------------------------SERVER-------------------------------------------------------------------
gcc -Wall -Wextra -O2 -pthread -o server mainServer.c dataStructures.c server.c dataStructures.h server.h


gcc -Wall -Wextra -g -O2 -pthread  -o server server.c serverThreadFunctions.c terminationAndRecovery.c timer.c selectiveRepeat.c dataStructures.h serverThreadFunctions.h -lm


----------------------------------------------------------CLIENT-------------------------------------------------------------------

gcc -Wall -Wextra -O2 -pthread -o client client.c dataStructures.c dataStructures.h

gcc -Wall -Wextra -g -O2 -pthread  -o client client.c terminationAndRecovery.c timer.c selectiveRepeat.c dataStructures.h -lm


-----------------------------------------------------------------------------------------------------------------------------------

TODO : RICORDA DI RIMETTERE TUTTO AI VALORI NORMALI

delay dei pacchetti (devi scaricare iproute2)

sudo tc qdisc add dev lo root netem delay 100ms
sudo tc qdisc change dev lo root netem delay 200ms
sudo tc qdisc change dev lo root netem delay 0ms

perdita dei pacchetti

sudo tc qdisc add dev lo root netem loss 0.1%
sudo tc qdisc change dev lo root netem loss 0%

TODO : sizeof() funziona o a compiletime o a runtime con variable sized arrays, non fare sizeof(istanza) ma sizeof(tipodidato) in OGNI FILE

POTREPPE ESSERE IMPORTANTISSIMO:
http://stackoverflow.com/questions/12785266/problem-in-udp-socket-programing-in-c

TODO : togliere "CIAONE" in fase di instaurazione della connessione
TODO : capire perchè dopo la push non funziona la list (nstoptimer va in SIGSEGV)

Thread 2 "client" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7ffff77f0700 (LWP 3032)]
0x0000000000404ef5 in nStopTimer
    (ackN=3856,
    deletetimermtx=deletetimermtx@entry=0x6083a0 <deletetimermtx>,
    details=details@entry=0x6086c0 <sendServer>,
    currentSlot=currentSlot@entry=2)
at timer.c:229

229	    if(abs((((details->selectiveWnd)[(ackN) % (details->windowDimension)]).wheelTimer)->posInWheel - currentSlot) > 3) {


TODO : aggiustare il timer (mette tutto nella cella 9 mentre currentTimer = 1)

ritrasmissione di ack se mi arrivano pacchetti anche da operazioni passate, perchè potrebbero essere andati persi gli ack

grep currentTimer *
Binary file client matches
client.c:    volatile struct timer currentTimer;
client.c:                currentTimer = *wheel[currentTimeSlot].nextTimer;
client.c:                if (currentTimer.isValid == 1) {
client.c:                    printf("ho trovato il timer del pacchetto %d, è il primo della coda\n", currentTimer.seqNum);
client.c:                    currentTimer.isValid = 0;
client.c:                    if (write(pipeRT[1], (int *) &currentTimer.seqNum, sizeof(int)) == -1) {
client.c:                while (currentTimer.nextTimer != NULL) {
client.c:                    currentTimer = *(currentTimer.nextTimer);
client.c:                    if (currentTimer.isValid == 1) {
client.c:                        printf("ho trovato il timer del pacchetto %d\n", currentTimer.seqNum);
client.c:                        currentTimer.isValid = 0;
client.c:                        if (write(pipeRT[1], (int *) &currentTimer.seqNum, sizeof(int)) == -1) {
dataStructures.h://int tBackoff(struct timer * currentTimer, int dimension, double pValue);
grep: logs: Is a directory
note.txt:bisogna assolutamente lavorare su currentTimer. per Files grandi il listener non stoppa nulla.
Binary file server matches
serverThreadFunctions.c:    struct timer * currentTimer;
serverThreadFunctions.c:        currentTimer = wheel[currentTimeSlot];
serverThreadFunctions.c:        while (currentTimer != NULL)
serverThreadFunctions.c:            printf("ho trovato il timer del pacchetto %d\n", currentTimer->seqNum);
serverThreadFunctions.c:            currentTimer = NULL;
serverThreadFunctions.c:            //currentTimer = currentTimer->nextTimer;
serverThreadFunctions.c:    volatile struct timer currentTimer;
serverThreadFunctions.c:/*        if(currentTimer == NULL)
serverThreadFunctions.c:            currentTimer = *wheel[currentTimeSlot].nextTimer;
serverThreadFunctions.c:            if (currentTimer.isValid == 1)
serverThreadFunctions.c:                currentTimer.isValid = 0;
serverThreadFunctions.c:                if (write(pipeRT[1], (int * ) &currentTimer.seqNum, sizeof(int)) == -1) {
serverThreadFunctions.c:            while(currentTimer.nextTimer != NULL)
serverThreadFunctions.c:                currentTimer = *(currentTimer.nextTimer);
serverThreadFunctions.c:                if (currentTimer.isValid == 1)
serverThreadFunctions.c:                    currentTimer.isValid = 0;
serverThreadFunctions.c:                    if (write(pipeRT[1], (int * ) &currentTimer.seqNum, sizeof(int )) == -1) {
timer.c:        timer * currentTimer;
timer.c:        currentTimer = &wheel[currentTimeSlot];
timer.c:        while(currentTimer != NULL)
timer.c:            retransmitTimer = calSlot(currentTimer, RTT);
timer.c:            currentTimer = currentTimer->nextTimer;
timer.c:int tBackoff(struct timer * currentTimer, int dimension, double pValue)
timer.c:    rtxTimer = currentTimer->transmitN * pValue;

